

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>8. 应用数据持久化</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="7. 应用的微服务化" href="应用的微服务化.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/sphinx.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录：</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="容器云概述.html">1. 开源容器云概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="初探OpenShift容器云.html">2. 初探OpenShift容器云</a></li>
<li class="toctree-l1"><a class="reference internal" href="OpenShift架构探秘.html">3. OpenShift 架构探秘</a></li>
<li class="toctree-l1"><a class="reference internal" href="OpenShift企业部署.html">4. OpenShift 企业部署</a></li>
<li class="toctree-l1"><a class="reference internal" href="容器应用的构建与部署自动化.html">5. 容器应用的构建与部署自动化</a></li>
<li class="toctree-l1"><a class="reference internal" href="持续集成与部署.html">6. 持续集成与部署</a></li>
<li class="toctree-l1"><a class="reference internal" href="应用的微服务化.html">7. 应用的微服务化</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. 应用数据持久化</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">8.1. 无状态应用与有状态应用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">8.1.1. 非持久化的窑器</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">8.1.2. 容器数据持久化</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id5">8.2. 持久化卷与持久化卷请求</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">8.3. 持久化卷与储存</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#host-path">8.3.1. Host Path</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nfs">8.3.2. NFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#glusterfs">8.3.3. GlusterFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ceph">8.3.4. Ceph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#openstack-cinder">8.3.5. OpenStack Cinder</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id7">8.4. 存储资源定向匹配</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">8.4.1. 创建持久化卷</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">8.4.2. 标记标签</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">8.4.3. 创建持久化卷请求</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">8.4.4. 请求与资源定向匹配</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">8.4.5. 标签选择器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id13">8.5. 实战：持久化的镜像仓库</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id14">8.5.1. 检查挂载点</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">8.5.2. 备份数据</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id16">8.5.3. 创建存储</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">8.5.4. 创建持久化卷</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id18">8.5.5. 创建持久化卷请求</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id19">8.5.6. 关联持久化卷请求</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id20">8.6. 本章小结</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">nest</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
                   

<div role="navigation" aria-label="breadcrumbs navigation">

    <ul class="wy-breadcrumbs">
        
        <li><a href="../index.html">首页</a> &raquo;</li>
        
        <li><span class="section-number">8. </span>应用数据持久化</li>
         
        <li class="wy-breadcrumbs-aside">
            <a href="https://pages.github.ibm.com/fsd-training/cvitube" class="fa fa-github"> CVITube</a>  
            <a href="../_sources/pages/应用数据持久化.md.txt" rel="nofollow"> View page source</a>  
        </li>
        
    </ul>

    
    <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1><span class="section-number">8. </span>应用数据持久化<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2><span class="section-number">8.1. </span>无状态应用与有状态应用<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>应用的有状态和无状态是根据应用是否有持久化保存数据的需求而言的，即持久化保存数据的应用为有状态的应用，反之则为元状态的应用。常见的系统往往是有状态的应用，比如对于微博和微信这类应用，所有用户发布的内容和留言都是要保存记录的。但是一个系统往往是由众多微服务或更小的应用模块构成的。有的微服务或模块其实并没有数据持久化的需求。例如，搭建一个Wordpress 博客系统需要部署一个前端的PHP 应用，以及一个后端的MySQL 数据库。虽然整个博客系统有持久化的需求，是一个有状态的系统，但是其子模块前端PHP 应用并没有将数据保存在本地，而是存放到MySQL 数据库中。所以一个Wordpress 系统可以拆解成一个无状态的前端以及一个有状态的后端。有状态和无状态的应用在现实当中比比皆是。从实例数量上来说，无状态的应用应该会更多一些，因为对大多数的系统而言，读请求的数量往往远远高于写请求的数量。</p>
<div class="section" id="id3">
<h3><span class="section-number">8.1.1. </span>非持久化的窑器<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>容器的一个特点是当容器退出后，其内部所有的数据和状态就会丢失。同样的镜像再次启动一个新的容器实例，该实例默认不会继承之前实例的状态。这对无状态应用来说不是问题，相反是一个很好的特性，可以很好地保证无状态应用的一致性。但是对于有状态的应用来说则是很大的障碍。试想一下，如果你的MySQL 容器每次重启后，之前所有的数据都丢失了，那将会是怎样一种灾难！</p>
</div>
<div class="section" id="id4">
<h3><span class="section-number">8.1.2. </span>容器数据持久化<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>不可避免地用户会在容器中运行有状态的应用，因此，在容器引擎的层面必须满足数据持久化的需求。Docker 在容器引擎的层面提供了卷（ Volume ）的概念。用户可以建立数据卷容器来为容器提供持久化的支持。容器实例需要将持久化的数据写人数据卷容器中保存。当应用容器退出时，数据仍然安然地在储存于数据卷容器当中。</p>
<p>此外Docker 以插件的形式支持多种存储方式。通过卷插件（ Volume Plugin），目前Docker容器可以对接主机的目录、软件定义存储（如GlusterFS 及Ceph ）、云存储（如AWS 及GCE等公有云提供的云储存）及储存管理解决方案（如Flocker 等） 。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>详细的Docker Volume Plugin 列表请参考： <a class="reference external" href="https://docs.docker.com/engine/extend/legacy_plugins/#volume-plugins">https://docs.docker.com/engine/extend/legacy_plugins/#volume-plugins</a> 。</p>
</div>
</div>
</div>
<div class="section" id="id5">
<h2><span class="section-number">8.2. </span>持久化卷与持久化卷请求<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>Docker 在容器引擎的层面提供了卷的机制来满足容器数据持久化的需求。在多主机的环境下，容器云的场景中需要考虑的细节会更多。比如一个有状态应用的容器实例从一个主机漂移到另一台主机上时，如何保证其所挂载的卷仍然可以被正确对接。此外， 在云平台上，用户需要以一种简单方式获取和消费存储这一资源，而无须过度关心底层的实现细节。比如用户有一个应用，需要一个lOOGB 的高速存储空间储存大量的零碎文件。用户需要做的是向云平台提交资源申请，然后获取并消费这个储存资掘，而不需要操心底层这个存储究竟是具体来自哪一台储存服务器的哪一块磁盘。</p>
<img alt="持久化卷和持久化卷生命周期" src="../_images/ps_lifecycle.jpg" />
<p>图8-1 持久化卷和持久化卷生命周期</p>
<p>为了满足容器用户在云环境储存的需求。Kubernetes 在容器编排的层面提供了持久化卷( Persistent Volume, PV ）及持久化卷请求（ Persistent Volume Claim, PVC ）的概念。持久化卷定义了具体的储存的连接信息，如NFS 服务器的地址和端口、卷的位置、卷的大小及访问方式。在OpenShift中，集群管理员会定义一系列的持久化卷，形成一个持久化卷的资源池。当用户部署有持久化需求的容器应用时，用户需要创建一个持久化卷请求。在这个请求中，用户申明所需储存的大小及访问方式。Kubernetes 将负责根据用户的持久化卷请求找到匹配需求的持久化卷进行对接。最终的结果是容器启动后，持久化卷定义的后端储存将会被挂载到容器的指定目录。OpenShift在架构上基于Kubernetes ，因此用户可以在OpenShift中使用Kubernetes 的持久化卷与持久化卷请求的储存供给模型，以满足数据持久化的需求。</p>
<p>持久化卷的生命周期</p>
<p>图8-2 所示的持久化卷的生命周期一共分为“供给”，“绑定”，“使用”，“回收”及“释放”五个阶段。</p>
<img alt="持久化卷请求模型" src="../_images/pv_lifecycle.jpg" />
<p>图8-2 持久化卷请求模型</p>
<p>1 . 供给</p>
<p>在Kubernetes 中，储存资源的供给分为两种类型：静态供给和动态供给。对于静态供给， 集群管理员会创建一些列的持久化卷，形成一个持久化卷的资源池。动态供给是集群所在的基础设施云根据需求动态地创建出持久化卷，如OpenStack 、Amazon WebService 。这些资源池中的持久化卷将会在后续与具体的持久化卷请求进行对接。下面是一个持久化卷的定义示例，其定义了一个NFS 的存储后端，其大小为lGB ，访问方式为ReadWriteOnce ，即独占读写。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>{

        &quot;apiVersion&quot;: &quot;v1&quot;,
        &quot;kind&quot;:&quot;PersistentVolume&quot; ,
        &quot;metadata&quot; :{
                &quot;name&quot; ： &quot;1Gi&quot;
        },
        &quot;spec&quot;: {
                &quot;capacity&quot;: {
                        &quot;storage&quot;: &quot;1Gi&quot;
                },
                &quot;accessModes&quot;: [&quot;ReadWriteOnce&quot;],
                &quot;nfs&quot;: {
                        &quot;path&quot;: &quot;/var/export/pvs/${volume}&quot;,
                        &quot;server&quot;:&quot;192.168.0.254&quot;
                },
                &quot;persistentVolumeReclaimPolicy&quot;：&quot;Retain&quot;
        }
}
</pre></div>
</div>
<p>访问方式是描述持久化卷的访问特性，比如是只读还是可读可写。是只能被一个Node节点挂载，还是可以被多个Node 节点使用。目前有三种访问方式可供选择。</p>
<blockquote>
<div><ul class="simple">
<li><p>ReadWriteOnce ：可读可写，只能被一个Node 节点挂载。</p></li>
<li><p>ReadWriteMany ：可读可写，可以被多个Node 节点挂载。</p></li>
<li><p>ReadOnlyMany ：只读，能被多个Node 节点挂载。</p></li>
</ul>
</div></blockquote>
<p>这里要注意的是，访问方式和后端使用的储存有很大的关系，并不是将一个持久化卷设置为ReadWriteMany ，这个持久化卷就可以被多个Node 节点挂载。比如OpenStack 的Cinder和CephRDB 这些块设备就不支持ReadWriteMany 这种模式。在Kubernetes 的官方文档中对各种后端存储的访问方式有详细的描述。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Kubernetes 关于持久化卷的描述： <a class="reference external" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">https://kubernetes.io/docs/concepts/storage/persistent-volumes/</a></p>
</div>
<ol class="arabic simple" start="2">
<li><p>绑定</p></li>
</ol>
<p>用户在部署容器应用时会定义持久化卷请求持久化卷请求。用户在持久化卷请求中声明需要的储存资源的特性，如大小和访问方式。Kubernetes 负责在持久化卷的资源池中寻找配的持久化卷对象，并将持久化卷请求与目标持久化卷进行对接。这时持久化卷和持久化卷请求的状态都将变成Bound ，即绑定状态。</p>
<p>下面是一个持久化卷请求的定义示例。在这个例子中，用户定义了一个名为claim1 、大小为5GB 、访问方式为ReadWriteOnce 的持久化卷请求。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>{

        &quot;apiVersion&quot;:&quot;v1&quot;,
        &quot;kind&quot;:&quot;PersistentVolumeClaim&quot;,
        &quot;apiVersion&quot;：&quot;vl&quot;,
        &quot;metadata&quot;:{
                &quot;name&quot;:&quot;claim1&quot;
        },
        &quot;spec&quot;:{
                &quot;accessModes&quot;:[
                        &quot;ReadWriteOnce&quot;
                ],
                &quot;resources&quot;:{
                        &quot;requests&quot;:{
                                &quot;storage&quot; :&quot;5Gi&quot;
                        }
                }
        }
}
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>使用</p></li>
</ol>
<p>在用户部署容器时会在Deployment Config 的容器定义中指定Volume 的挂载点，并将这个挂载点和持久化卷请求关联。当容器启动时，持久化卷指定的后端储存被挂载到容器定义的挂载点上。应用在容器内部运行，数据通过挂载点最终写入后端储存中，从而实现持久化。下面是一个容器定义的例子。可以看到这个容器定义的名为www 的volumeMounts 挂载点指向/var/www/html 目录。同时， www 这个挂载点指向了持久化卷请求claim1 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">spec</span><span class="p">:</span>
   <span class="n">containers</span><span class="p">:</span>
     <span class="o">-</span> <span class="n">nane</span><span class="p">:</span> <span class="n">webserver</span>
       <span class="n">image</span> <span class="p">:</span> <span class="n">httpd</span>
<span class="n">volumeMounts</span> <span class="p">:</span>
     <span class="o">-</span> <span class="n">mountPath</span> <span class="p">:</span><span class="s2">&quot;/var/www/html&quot;</span>
       <span class="n">name</span><span class="p">:</span> <span class="n">www</span>
   <span class="n">volumes</span> <span class="p">:</span>
     <span class="o">-</span> <span class="n">name</span> <span class="p">:</span> <span class="n">www</span>
<span class="n">persistentVolumeClaim</span><span class="p">:</span>
<span class="n">claimName</span> <span class="p">:</span> <span class="n">claim1</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>释放</p></li>
</ol>
<p>当应用下线不再使用储存时，可以删除相关的持久化卷请求，这样持久化卷的状态就会变成released ， 即释放。</p>
<ol class="arabic simple" start="5">
<li><p>回收</p></li>
</ol>
<p>当持久化卷的状态变为released 后， Kubernetes 将根据持久化卷定义的回收策略回收持久化卷。当前支持的回收策略有三种：</p>
<blockquote>
<div><ul class="simple">
<li><p>Retian ：保留数据，人工回收持久化卷。</p></li>
<li><p>Recycle ： 通过执行m -rf 删除卷上的所有数据。目前只有NFS 及Host Path 支持这种方式。</p></li>
<li><p>Delete ：动态地删除后端储存。该模式需要下层IaaS 的支持，目前AWS EBS 、GCEPD 及OpenStack Cinder 支持这种模式。</p></li>
</ul>
</div></blockquote>
<p>Kubernetes 通过持久化卷及持久化卷请求这一供给模型为用户提供容器云上的储存消费的途径。在这个模型下，用户可以简单快速地构建出满足应用需要的容器云上的储存解决方案。在Kubernetes 1.3 中，持久化卷和持久化卷请求引入了标签的概念，这了给用户更大的灵活性。例如，我们可以为不同类型的持久化卷贴上不同的标签，如“SSD”，“RAID0”，“Ceph”，“深圳机房”或“美国机房”等。用户在持久化卷请求中可以定义相应地标签选择器，从而获取更精确匹配应用需求的后端持久化卷。</p>
</div>
<div class="section" id="id6">
<h2><span class="section-number">8.3. </span>持久化卷与储存<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>Kubernetes 的持久化卷支持的后端储存的类型很多，包括宿主机的本地目录（ Host Path ）、
网络文件系统（ NFS ）、OpenStack Cinder 分布式储存（如GlusterFS 、Ceph RBD 及CephFS)
及云储存（如AWS Elastic Block Store 或GCE Persistent Disk ） 等。一个常见的困惑是“我应该选择哪一种储存？”不同的储存后端有不同特性，并不存在一种满足所有场景的储存。用户应该根据当前容器应用的需求，选择满足需求的储存。</p>
<div class="section" id="host-path">
<h3><span class="section-number">8.3.1. </span>Host Path<a class="headerlink" href="#host-path" title="Permalink to this headline">¶</a></h3>
<p>Host Path 类型的储存是指容器挂载所在的计算机点主机上的目录。这种方式只适合用于以测试为目的的场景中。允许容器挂载主机目录引入了安全风险。依赖于某一节点上的数据也使得容器和某一计算节点产生了较强的绑定关系性，引入了单点失效的风险。</p>
</div>
<div class="section" id="nfs">
<h3><span class="section-number">8.3.2. </span>NFS<a class="headerlink" href="#nfs" title="Permalink to this headline">¶</a></h3>
<p>NFS 是一种常用的储存类型。NFS 已经存在了很长一段时间，在UNIX 和Linux 上被广泛应用，所有的Linux 系统管理员对它都不会感到陌生。因为系统支持比较广泛， NFS 目前是较为常见的持久化卷的储存后端。下面是NFS 持久化卷的一个示例。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">apiVersion</span><span class="p">:</span> <span class="n">v1</span>
<span class="n">kind</span><span class="p">:</span> <span class="n">PersistentVolume</span>
<span class="n">metadata</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">pv0001</span>
<span class="n">spec</span><span class="p">:</span>
    <span class="n">capacity</span><span class="p">:</span>
        <span class="n">storage</span><span class="p">:</span> <span class="mi">5</span><span class="n">Gi</span>
<span class="n">accessModes</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">ReadWriteOnce</span>
<span class="n">nfs</span> <span class="p">:</span>
        <span class="n">path</span><span class="p">:</span> <span class="o">/</span><span class="n">tmp</span>
        <span class="n">server</span><span class="p">:</span> <span class="mf">172.17</span><span class="o">.</span><span class="mf">0.2</span>
<span class="n">persistentVolumeReclaimPolicy</span><span class="p">:</span> <span class="n">Recycle</span>
</pre></div>
</div>
</div>
<div class="section" id="glusterfs">
<h3><span class="section-number">8.3.3. </span>GlusterFS<a class="headerlink" href="#glusterfs" title="Permalink to this headline">¶</a></h3>
<p>GlusterFS 是一个开源的分布式文件系统。GlusterFS 具有很强的弹性扩展能力，用户可以在通用的计算机硬件上使用GlusterFS 构建出PB 级别的储存集群用于储存如视频、图片及资料等多种类型的数据。</p>
<p>GlusterFS 的主要特点是：</p>
<blockquote>
<div><ul class="simple">
<li><p>完全基于软件实现。完全不依赖于特定的主机、储存、网络硬件。</p></li>
<li><p>高度弹性扩展。用户可以构建储存的容量从GB 到PB 级的储存。</p></li>
<li><p>高可用。数据可以在储存集成中保留多个副本，防止单点失效。</p></li>
<li><p>兼容PO SIX 文件系统标准。基于标准，因此对上层应用进行改造。</p></li>
<li><p>支持多种不同种类的卷。如复制卷、分布式卷及条带卷，满足不同场景的需求。</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>GlusterFS项目主页： <a class="reference external" href="https://www.gluster.org/">https://www.gluster.org/</a> 。</p>
</div>
<p>在OpenShift 中使用GlusterFS ，首先需要创建一个端点（ Endpoint ），描述GlusterFS 的服务器所在的信息。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">apiVersion</span> <span class="p">:</span> <span class="n">v1</span>
<span class="n">kind</span><span class="p">:</span> <span class="n">Endpoints</span>
<span class="n">metadata</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">glusterfs</span><span class="o">-</span><span class="n">cluster</span>
<span class="n">subsets</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">addresses</span><span class="p">:</span>
          <span class="o">-</span> <span class="n">ip</span><span class="p">:</span> <span class="mf">192.168</span><span class="o">.</span><span class="mi">122</span> <span class="o">.</span> <span class="mi">221</span>
      <span class="n">ports</span><span class="p">:</span>
          <span class="o">-</span> <span class="n">port</span><span class="p">:</span> <span class="mi">1</span>
    <span class="o">-</span> <span class="n">addresses</span><span class="p">:</span>
          <span class="o">-</span> <span class="n">ip</span><span class="p">:</span> <span class="mf">192.168</span><span class="o">.</span><span class="mi">122</span> <span class="o">.</span> <span class="mi">222</span>
      <span class="n">ports</span><span class="p">:</span>
          <span class="o">-</span> <span class="n">port</span> <span class="p">:</span> <span class="mi">1</span>
</pre></div>
</div>
<p>建立Endpoint 后，再创建持久化卷，并引用前文定义的Endpoint 。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">apiVersion</span><span class="p">:</span> <span class="n">v1</span>
<span class="n">kind</span> <span class="p">:</span> <span class="n">PersistentVolume</span>
<span class="n">metadata</span> <span class="p">:</span>
      <span class="n">name</span> <span class="p">:</span> <span class="n">gluster</span><span class="o">-</span><span class="n">default</span><span class="o">-</span><span class="n">volume</span>
<span class="n">spec</span><span class="p">:</span>
      <span class="n">capacity</span><span class="p">:</span>
          <span class="n">storage</span> <span class="p">:</span> <span class="mi">2</span><span class="n">Gi</span>
<span class="n">accessModes</span><span class="p">:</span>
          <span class="o">-</span> <span class="n">ReadWriteMany</span>
<span class="n">glusterfs</span><span class="p">:</span>
          <span class="n">endpoints</span><span class="p">:</span> <span class="n">glusterfs</span><span class="o">-</span><span class="n">cluster</span>
          <span class="n">path</span><span class="p">:</span> <span class="n">myVol1</span>
<span class="n">readOnly</span><span class="p">:</span> <span class="n">false</span>
<span class="n">persistentVolumeReclaimPolicy</span> <span class="p">:</span> <span class="n">Retain</span>
</pre></div>
</div>
</div>
<div class="section" id="ceph">
<h3><span class="section-number">8.3.4. </span>Ceph<a class="headerlink" href="#ceph" title="Permalink to this headline">¶</a></h3>
<p>Ceph 是当前非常流行的开源分布式储存解决方案。和GlusterFS 类似， Ceph 也是一个完全基于软件实现的分布式储存。Ceph 的一个特点是，其原生提供了多种接口方式，如基于RESTful 的对象、块（ Block ）和文件系统。GlusterFS 和Ceph 都是非常优秀的分布式储存，很多人喜欢将它们进行比较。应该说GlusterFS 和Ceph 各有优劣，在伯仲之间，青菜萝卡各有所爱。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Ceph项目主页： <a class="reference external" href="https://ceph.io/">https://ceph.io/</a> 。</p>
</div>
<p>Kubernetes 的持久化卷支持两种方式挂载Ceph 储存：块设备（RBD）及文件系统（ CephFS ） 。目前， 由于Ceph 官方认为CephFS 尚未完全成熟以达到企业生产使用的标准，因此虽然Kubernetes 和OpenShift 的代码中已经存在CephFS 的支持，但是并不推荐在生产中使用。</p>
<p>在挂接Ceph 的块设备RBD 前，需要先创建一个Secret 对象储存访问Ceph 服务器所需
的密钥。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">apiVersion</span><span class="p">:</span> <span class="n">v1</span>
<span class="n">kind</span> <span class="p">:</span> <span class="n">Secret</span>
<span class="n">metadata</span> <span class="p">:</span>
     <span class="n">name</span> <span class="p">:</span> <span class="n">ceph</span><span class="o">-</span><span class="n">secret</span>
<span class="n">data</span><span class="p">:</span>
     <span class="n">key</span><span class="p">:</span> <span class="n">QVFBOFF2SlZheUJQRVJBQWgvS2cwTllaQUhPQno3akZwekxxdGc9PQ</span><span class="o">==</span>
</pre></div>
</div>
<p>Ceph 持久化卷的定义示例如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">apiVersion</span> <span class="p">:</span> <span class="n">vl</span>
<span class="n">kind</span><span class="p">:</span> <span class="n">PersistentVolume</span>
<span class="n">metadata</span><span class="p">:</span>
     <span class="n">name</span><span class="p">:</span> <span class="n">ceph</span><span class="o">-</span><span class="n">pv</span>
<span class="n">spec</span><span class="p">:</span>
     <span class="n">capacity</span> <span class="p">:</span>
          <span class="n">storage</span><span class="p">:</span> <span class="mi">2</span><span class="n">Gi</span>
<span class="n">accessModes</span> <span class="p">:</span>
          <span class="o">-</span> <span class="n">ReadWriteOnce</span>
<span class="n">rbd</span><span class="p">:</span>
          <span class="n">monitors</span><span class="p">:</span>
              <span class="o">-</span><span class="mf">192.168</span><span class="o">.</span><span class="mf">122.133</span><span class="p">:</span><span class="mi">6789</span>
         <span class="n">pool</span> <span class="p">:</span> <span class="n">rbd</span>
         <span class="n">image</span><span class="p">:</span> <span class="n">ceph</span><span class="o">-</span><span class="n">image</span>
         <span class="n">user</span><span class="p">:</span> <span class="n">admin</span>
<span class="n">secretRef</span><span class="p">:</span>
         <span class="n">name</span><span class="p">:</span> <span class="n">ceph</span><span class="o">-</span><span class="n">secret</span>
<span class="n">fsType</span><span class="p">:</span> <span class="n">ext4</span>
<span class="n">readOnly</span><span class="p">:</span> <span class="n">false</span>
<span class="n">persistentVolumeReclaimPolicy</span><span class="p">:</span> <span class="n">Recycle</span>
</pre></div>
</div>
</div>
<div class="section" id="openstack-cinder">
<h3><span class="section-number">8.3.5. </span>OpenStack Cinder<a class="headerlink" href="#openstack-cinder" title="Permalink to this headline">¶</a></h3>
<p>Cinder 是OpenStack 块储存服务，负责为OpenStack 上的主机实例提供灵活的储存支持。对于运行在OpenStack 上的OpenShift集群，用户可以定义基于OpenStack Cinder 的持久化卷。Cinder 持久化卷的定义示例如下。volume ID 属性指向了管理员在Cinder 创建的数据卷的唯一标识。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>apiVersion ：&quot;v1&quot;
kind : &quot;PersistentVolume&quot;
metadata:
     name :&quot;pv0001&quot;
spec :
     capacity:
         storage :&quot;5Gi&quot;
accessModes :
         - &quot;ReadWriteOnce&quot;
cinder:
      fsType : &quot;ext3&quot;
      volumeID ：&quot;f37a03aa-6212-4c62-a805-9ce139fab18”
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在使用Cinder 持久化卷前， OpenShift必须通过配置与底层的OpenStack 整合。详细的配置方法请参考Open Shi仕的官方文档：<a class="reference external" href="https://docs.openshift.com/container-platform/4.5/welcome/index.html">https://docs.openshift.com/container-platform/4.5/welcome/index.html</a></p>
</div>
</div>
</div>
<div class="section" id="id7">
<h2><span class="section-number">8.4. </span>存储资源定向匹配<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>不同用户对储存的需求不尽相同，除了大小和访问方式外，可能还有对磁盘的速度、储存所在的数据中心等有特殊的要求。为了灵活满足储存需求和储存资源的对接， Kubernetes支持为持久化卷打上不同的标签（ Label ） ，在持久化卷请求侧则通过定义标签选择器来申明该持久化卷请求具体需要与什么样的持久化卷匹配。通过标签和标签选择器（ Selector ) ,Kubernetes为持久化卷与持久化卷请求实现了定向匹配。</p>
<div class="section" id="id8">
<h3><span class="section-number">8.4.1. </span>创建持久化卷<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>创建如下例子中的两个持久化卷pv000l 及pv0002 。这两个持久化卷具有相同的大小和访问方式， 且都没有任何标签。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc get pv --show-labels</span>
<span class="n">NAME</span>   <span class="n">CAPACITY</span> <span class="n">ACCESSMODES</span> <span class="n">STATUS</span>  <span class="n">CLAIM</span> <span class="n">REASON</span> <span class="n">AGE</span>  <span class="n">LABELS</span>
<span class="n">pv0001</span> <span class="n">lGi</span>      <span class="n">RWO</span>         <span class="n">Availab</span>              <span class="mi">1</span><span class="n">m</span>   <span class="o">&lt;</span><span class="n">none</span><span class="o">&gt;</span>
<span class="n">pv0002</span> <span class="n">lGi</span>      <span class="n">RWO</span>         <span class="n">Availab</span>              <span class="mi">1</span><span class="n">m</span>   <span class="o">&lt;</span><span class="n">none</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3><span class="section-number">8.4.2. </span>标记标签<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>通过oc label 命令为持久化卷pv0002 打上标签disktype=ssd 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc label pv pv0002 disktype=ssd</span>
<span class="n">persistentvolume</span> <span class="s2">&quot;pv0002&quot;</span> <span class="n">labeled</span>
</pre></div>
</div>
<p>再次查看持久化卷的标签，可以看到pv0002 已经打上了disktype=ssd的标签。pv0001 仍然没有任何标签。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span> <span class="p">]</span> <span class="c1"># oc get pv --show-labels</span>
<span class="n">NAME</span>   <span class="n">CAPACITY</span> <span class="n">ACCESSMODES</span> <span class="n">STATUS</span>     <span class="n">CLAIM</span> <span class="n">REASON</span> <span class="n">AGE</span> <span class="n">LABELS</span>
<span class="n">pv0001</span> <span class="n">lGi</span>      <span class="n">RWO</span>         <span class="n">Available</span>               <span class="mi">2</span><span class="n">m</span>  <span class="o">&lt;</span><span class="n">none</span><span class="o">&gt;</span>
<span class="n">pv0002</span> <span class="n">lGi</span>      <span class="n">RWO</span>         <span class="n">Available</span>               <span class="mi">2</span><span class="n">m</span>  <span class="n">disktype</span><span class="o">=</span><span class="n">ssd</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3><span class="section-number">8.4.3. </span>创建持久化卷请求<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>创建一个带标签选择器的持久化卷请求。如下面的定义所示，这个持久化卷请求的储存空间大小为lGi ，访问方式是只读共享RWO 。标签选择器的类型为matchLabels ，定义值为”disktype”: ” ssd” ，即表示与该持久化卷请求匹配的持久化卷必须要带有”disktype”：”ssd”标签。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># cat pvc0001.json</span>
<span class="p">{</span>
        <span class="s2">&quot;kind&quot;</span><span class="p">:</span><span class="s2">&quot;PersistentVolumeClaim&quot;</span><span class="p">,</span>
    <span class="s2">&quot;apiVersion&quot;</span><span class="p">:</span><span class="s2">&quot;v1&quot;</span><span class="p">,</span>
    <span class="s2">&quot;metadata&quot;</span><span class="p">:{</span>
         <span class="s2">&quot;name&quot;</span> <span class="p">:</span> <span class="s2">&quot;pvc0001&quot;</span><span class="p">,</span>
         <span class="s2">&quot;creationTimestamp&quot;</span><span class="p">:</span> <span class="n">null</span>
     <span class="p">},</span>
     <span class="s2">&quot;spec&quot;</span><span class="p">:{</span>
         <span class="s2">&quot;accessModes&quot;</span><span class="p">:[</span>
              <span class="s2">&quot;ReadWriteOnce&quot;</span>
          <span class="p">]</span>
          <span class="s2">&quot;selector&quot;</span><span class="p">:{</span>
               <span class="s2">&quot;matchLabels &quot;</span><span class="p">:{</span>
                    <span class="s2">&quot;disktype&quot;</span><span class="p">:</span><span class="s2">&quot;ssd&quot;</span>
                <span class="p">}</span>
           <span class="p">},</span>
          <span class="s2">&quot;resources&quot;</span><span class="p">:{</span>
                <span class="s2">&quot;requests&quot;</span><span class="p">:{</span>
                      <span class="s2">&quot;storage&quot;</span><span class="p">:</span><span class="s2">&quot;1Gi&quot;</span>
                 <span class="p">}</span>
           <span class="p">}</span>
      <span class="p">},</span>
      <span class="s2">&quot;status&quot;</span><span class="p">:{}</span>
<span class="p">}</span>
<span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc create -f pvc0001.json</span>
<span class="n">persistentvolumeclaim</span> <span class="s2">&quot;pv0001&quot;</span> <span class="n">created</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h3><span class="section-number">8.4.4. </span>请求与资源定向匹配<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>持久化卷请求创建完后，查看持久化卷的状态，可以看到虽然pv0001 和pv0002 在空间大小和访问方式上都满足了pvc0001的要求，但是pvc0001 最终匹配上的是带有目标标签的pv0002 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">-</span><span class="p">]</span><span class="c1"># oc get pv --show-labels</span>
<span class="n">NAME</span>   <span class="n">CAPACITY</span> <span class="n">ACCESSMODES</span> <span class="n">STATUS</span>    <span class="n">CLAIM</span>                 <span class="n">REASON</span>         <span class="n">AGE</span> <span class="n">LABELS</span>
<span class="n">pv0001</span> <span class="n">lGi</span>      <span class="n">RWO</span>         <span class="n">Available</span>                       <span class="mi">13</span><span class="n">m</span> <span class="o">&lt;</span><span class="n">none</span><span class="o">&gt;</span>
<span class="n">pv0002</span> <span class="n">lGi</span>      <span class="n">RWO</span>         <span class="n">Bound</span>     <span class="n">microservices</span><span class="o">/</span><span class="n">pvc000l</span> <span class="mi">13</span><span class="n">m</span> <span class="n">disktype</span><span class="o">=</span><span class="n">ssd</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3><span class="section-number">8.4.5. </span>标签选择器<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>目前， 持久化卷请求支持两种标签选择器： matchLabels 及matchExpressions 。matchLabels 选择器可以精确匹配一个或多个标签。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>......
&quot;selector&quot;:{
    &quot;matchLabels&quot;:{
         &quot;disktype&quot;：&quot;ssd&quot;
     }
},
......
</pre></div>
</div>
<p>matchExpressions 选择器支持标签的模糊匹配。用户可以使用操作符In或者NotIn对标签的值进行模糊匹配。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>.......
    matchExpressions:
         - {key: region , operator ：In, values: [shenzhen]}
         - {key: evn , operator ：NotIn, values: [testing]}
    ......
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h2><span class="section-number">8.5. </span>实战：持久化的镜像仓库<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p>前面几章的示例中部署了不少有状态的应用，比如OpenShift的内部镜像仓库、Jenkins和MySQL 。但是我们并没有为这些应用服务配置持久化卷，这样的结果是如果容器一旦意外退出，那么在容器内部的所有镜像、配置和数据都将消失殆尽。本节将为OpenShift 的内部仓库Registry 组件添加一个持久化的后端，实践容器应用的持久化。</p>
<div class="section" id="id14">
<h3><span class="section-number">8.5.1. </span>检查挂载点<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>首先，以集群管理员的身份登录OpenShift。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc login -u system:admin</span>
</pre></div>
</div>
<p>切换到default 项目， 查看Registry 的容器状态。通过输出可以看到Registry组件的容器正在运行。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc project default</span>
<span class="n">Now</span> <span class="n">using</span> <span class="n">project</span> <span class="s2">&quot;default&quot;</span> <span class="n">on</span> <span class="n">server</span> <span class="s2">&quot;https://192.168.172.167:8443&quot;</span><span class="o">.</span>
<span class="p">[</span> <span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc get pod</span>
<span class="n">NAME</span>                    <span class="n">READY</span>  <span class="n">STATUS</span>  <span class="n">RESTARTS</span> <span class="n">AGE</span>
<span class="n">docker</span><span class="o">-</span><span class="n">registry</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">blpar</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1</span>    <span class="n">Running</span> <span class="mi">12</span>       <span class="mi">9</span><span class="n">d</span>
<span class="n">ose</span><span class="o">-</span><span class="n">router</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="mi">03</span><span class="n">uqr</span>      <span class="mi">1</span><span class="o">/</span><span class="mi">1</span>    <span class="n">Running</span> <span class="mi">11</span>       <span class="mi">9</span><span class="n">d</span>
</pre></div>
</div>
<p>通过oc volume 命令可以查看系统对象关于Volume 的相关定义。执行oc volumes命令查看Registry 组件的Deployment Config 关于Volume 的定义。可以看见Registry 组件的定义中已经创建了一个Volume Mounts 对象registry-storage ，这个挂载点指向了/registry 目录。当前这个Volume Mounts 使用的empty directory 的卷，即数据保存在计算节点上。我们需要做的就是给registry-storage 这个挂载，点挂上一个持久化后端。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc volumes dc/docker-registry --all</span>
<span class="n">deploymentconfigs</span><span class="o">/</span><span class="n">docker</span><span class="o">-</span><span class="n">registry</span>
      <span class="n">empty</span> <span class="n">directory</span> <span class="k">as</span> <span class="n">registry</span><span class="o">-</span><span class="n">storage</span>
         <span class="n">mounted</span> <span class="n">at</span> <span class="o">/</span><span class="n">registry</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h3><span class="section-number">8.5.2. </span>备份数据<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>在前面章节的示例中已经向Regist可推送过不少镜像，所以当前容器内的/registry目录下已经有不少镜像相关的文件。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc rsh docker-registry-1-blpar &#39;du&#39; &#39;-sh&#39; &#39;/registry&#39;</span>
<span class="mf">1.2</span><span class="n">G</span>   <span class="o">/</span><span class="n">registry</span>
</pre></div>
</div>
<p>需要先备份这些文件。通过oc rsync 命令，可以将容器中某个目录的数据同步到宿主机上。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[root@master ~] # mkdir /root/backup
[root@master ~]# cd /root/backup/
[root@master backup]# oc rsync docker-registry-1-blpar:/registry
．输出忽略．
sent 13921 bytes received 1271378066 bytes 14870081.72 bytes/sec
total size is 1271108863 speedup is 1.00
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>oc rsync是一个很方便实用的命令，它可以双向同步容器和宿主机上的文件。要使用这个命令，目标容器内部必须有rync或者tar 这两个应用中的一个。</p>
</div>
</div>
<div class="section" id="id16">
<h3><span class="section-number">8.5.3. </span>创建存储<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>为了方便实验，本例选用NFS 作为后端的储存。在实际的生产中使用GlusterFS 、Ceph或其他储存后端的配置过程和步骤也类似。</p>
<p>执行以下命令创建一个NFS 的共享目录。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="n">backup</span><span class="p">]</span><span class="c1"># mkdir - p /exports/pvOOOl</span>
<span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="n">backup</span><span class="p">]</span><span class="c1"># yum y install nfs-utils rpcbind</span>
<span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="n">backup</span><span class="p">]</span><span class="c1"># chown nfsnobody:nfsnobody /exports/ -R</span>
<span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="n">backup</span><span class="p">]</span><span class="c1"># echo &quot;/exports/pv000l * (rw,sync,all _squash)&quot;&gt;&gt;/etc/exports</span>
<span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="n">backup</span><span class="p">]</span><span class="c1"># systemctl start rpcbind</span>
<span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="n">backup</span><span class="p">]</span><span class="c1"># exportfs -r</span>
<span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="n">backup</span><span class="p">]</span><span class="c1"># systemctl start nfs-server</span>
</pre></div>
</div>
<p>为了测试方便，暂时先关闭SELinux 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="n">backup</span><span class="p">]</span><span class="c1"># setenforce 0</span>
</pre></div>
</div>
<p>测试挂载该NFS 共享目录，并尝试创建一个文件。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># mount 192.168.172.167:/exports/pv0001 /mnt/</span>

<span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># touch /mnt/test</span>
<span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># ls /mnt</span>
<span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># rm - f /mnt/test</span>
<span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">-</span><span class="p">]</span><span class="c1"># umount /mnt/</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h3><span class="section-number">8.5.4. </span>创建持久化卷<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>根据上面创建的NFS 的信息，创建持久化卷。在实验主机上将如下JSON 保存成文件pv.json 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>{

&quot;apiVersion&quot;: &quot;v1&quot;,
&quot;kind&quot;:&quot;PersistentVolume&quot; ,
&quot;metadata&quot; :{
        &quot;name&quot; ： &quot;pv0001&quot;
},
&quot;spec&quot;: {
        &quot;capacity&quot;: {
                &quot;storage&quot;: &quot;5Gi&quot;
        },
        &quot;accessModes&quot;: [&quot;ReadWriteOnce&quot;],
        &quot;nfs&quot;: {
                &quot;path&quot;: &quot;/export/pv0001&quot;,
                &quot;server&quot;:&quot;192.168.172.167&quot;
        },
        &quot;persistentVolumeReclaimPolicy&quot;：&quot;Retain&quot;
}
}
</pre></div>
</div>
<p>执行oc create 创建持久化卷。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc create -f pv.json</span>
<span class="n">persistentvolume</span> <span class="s2">&quot;pv0001&quot;</span> <span class="n">created</span>
</pre></div>
</div>
<p>创建完毕后， 通过oc get pv 可以查看到刚创建成功的持久化卷，此时它的状态为Available ，即可用。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span> <span class="c1"># oc get pv</span>
<span class="n">NAME</span>   <span class="n">CAPACITY</span> <span class="n">ACCESSMODES</span> <span class="n">STATUS</span> <span class="n">CLAIM</span>  <span class="n">REASON</span> <span class="n">AGE</span>
<span class="n">pv0001</span> <span class="mi">5</span><span class="n">Gi</span>      <span class="n">RWO</span>         <span class="n">Available</span>            <span class="mi">13</span><span class="n">s</span>
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h3><span class="section-number">8.5.5. </span>创建持久化卷请求<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>下面将创建持久化卷请求， 声明应用的储存需求。在实验主机上将如下JSON 保存成文件pvc.json 。这里声明了需要3 GB 的后端储存，访问方式为ReadWriteOnce 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>{

        &quot;apiVersion&quot;:&quot;v1&quot;,
        &quot;kind&quot;:&quot;PersistentVolumeClaim&quot;,
        &quot;apiVersion&quot;：&quot;v1&quot;,
        &quot;metadata&quot;:{
                &quot;name&quot;:&quot;docker-registry-claim&quot;
        },
        &quot;spec&quot;:{
                &quot;accessModes&quot;:[
                        &quot;ReadWriteOnce&quot;
                ],
                &quot;resources&quot;:{
                        &quot;requests&quot;:{
                                &quot;storage&quot; :&quot;3Gi&quot;
                        }
                }
        }
}
</pre></div>
</div>
<p>执行oc create 创建持久化卷请求。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc create -f pvc.json</span>
<span class="n">persistentvolumeclaim</span> <span class="s2">&quot;docker-registry-claim&quot;</span> <span class="n">created</span>
</pre></div>
</div>
<p>查看持久化卷请求和持久化卷的状态，会发现系统已经将它们连接起来了。持久化卷和持久化卷请求的状态都已经变成Bound 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc get pvc</span>
<span class="n">NAME</span>                  <span class="n">STATUS</span> <span class="n">VOLUME</span> <span class="n">CAPACITY</span> <span class="n">ACCESSMODES</span> <span class="n">AGE</span>
<span class="n">docker</span><span class="o">-</span><span class="n">registry</span><span class="o">-</span><span class="n">claim</span> <span class="n">Bound</span>  <span class="n">pv0001</span> <span class="mi">5</span><span class="n">Gi</span>      <span class="n">RWO</span>         <span class="mi">18</span><span class="n">s</span>
<span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc get pv</span>
<span class="n">NAME</span>   <span class="n">CAPACITY</span> <span class="n">ACCESSMODES</span> <span class="n">STATUS</span> <span class="n">CLAIM</span>                        <span class="n">REASON</span> <span class="n">AGE</span>
<span class="n">pv0001</span> <span class="mi">5</span><span class="n">G</span>       <span class="n">RWO</span>         <span class="n">Bound</span> <span class="n">default</span><span class="o">/</span><span class="n">docker</span><span class="o">-</span><span class="n">registry</span><span class="o">-</span><span class="n">claim</span>        <span class="mi">5</span><span class="n">m</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h3><span class="section-number">8.5.6. </span>关联持久化卷请求<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>将备份的数据恢复到前文创建的NFS 目录中。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># mv /root/backup/registry/* /exports/pv0001/</span>
<span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># chown nfsnobody:nfsnobody /exports/ -R</span>
</pre></div>
</div>
<p>此时，可以测试删除Registry容器， Replication Controller 将重新创建它。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc delete pod docker-registry-1-blpar</span>
<span class="n">pod</span> <span class="s2">&quot;docker-registry-1-blpar&quot;</span> <span class="n">deleted</span>
<span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc get pod</span>
<span class="n">NAME</span>                    <span class="n">READY</span> <span class="n">STATUS</span>               <span class="n">RESTARTS</span> <span class="n">AGE</span>
<span class="n">docker</span><span class="o">-</span><span class="n">registry</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="mi">48</span><span class="n">j36</span> <span class="mi">0</span><span class="o">/</span><span class="mi">1</span>   <span class="n">ContainerCreating</span>    <span class="mi">0</span>        <span class="mi">3</span><span class="n">s</span>
<span class="n">ose</span><span class="o">-</span><span class="n">router</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="mi">03</span><span class="n">uqr</span>      <span class="mi">1</span><span class="o">/</span><span class="mi">1</span>   <span class="n">Running</span>              <span class="mi">11</span>       <span class="mi">9</span><span class="n">d</span>
</pre></div>
</div>
<p>容器启动后，再次检查容器/registry 目录，会发现目录的数据应消失。因为容器默认是不持久化数据的。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc rsh docker-registry-1-48j36 &#39;du&#39; &#39;-sh&#39; &#39;/registry&#39;</span>
<span class="mi">0</span> <span class="o">/</span><span class="n">registry</span>
</pre></div>
</div>
<p>为Reigstry的容器定义添加持久化卷请求docker-registry-claim ，并与挂载点registry-storage 关联。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span> <span class="c1"># oc volume dc/docker-registry --add --name=registry-storage -t pvc --claim-name=docker-registry-claim --overwrite</span>
<span class="n">deploymentconfigs</span><span class="o">/</span><span class="n">docker</span><span class="o">-</span><span class="n">registry</span>
</pre></div>
</div>
<p>Deployment Config 的容器定义修改后， OpenShift 会创建新的容器实例。检查容器/registry 目录，会发现目录的数据恢复了。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@master</span> <span class="o">~</span><span class="p">]</span><span class="c1"># oc rsh docker-registry-2-kmnfr &#39;du&#39; &#39;-sh&#39; &#39;/registry&#39;</span>
<span class="mf">1.</span> <span class="mi">2</span><span class="n">G</span> <span class="o">/</span><span class="n">registry</span>
</pre></div>
</div>
<p>至此，我们成功地将Registry 组件挂接上了持久化储存。本例的配置基于NFS 持久化卷实现，使用GlusterFS 或Ceph 持久化卷的过程也类似，只是持久化卷的定义需要稍做修改。</p>
</div>
</div>
<div class="section" id="id20">
<h2><span class="section-number">8.6. </span>本章小结<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h2>
<p>本章探索了持久化卷和持久化卷请求的使用。用户通过定义持久化卷请求声明应用储存的需求，系统自动对接资源池中的持久化卷，最终为容器挂载后端的储存。通过实验，为Registry 组件添加了持久化后端，通过这个例子读者已经掌握了为容器应用添加持久化储存的方法。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="应用的微服务化.html" class="btn btn-neutral float-left" title="7. 应用的微服务化" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Murphy

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>